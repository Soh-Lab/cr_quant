"""


2023-05-30 Linus A. Hein
"""

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from scipy.optimize import curve_fit


def read_data():
    """
    Reads the data, removes NaNs, concentrations of XA of more than 3mM, and normalizes any
    concentrations to be given in M.

    Adapted from code by Sharon S. Newman.

    :return: pandas dataframe of the real-world data.
    """
    df = pd.read_csv('/data/2023_05_22_CR8_combined_2colreads.csv')
    df = df.dropna()
    # Convert all concentrations to M
    df[['xa_M', 'kyn_M']] = df[['xa_uM', 'kyn_uM']] * 10. ** -6
    df = df.drop(columns=['xa_uM', 'kyn_uM'])
    # samples where XA conc were above 3mM wasn't fully dissolved. Remove.
    df = df[(df['xa_M'] < 3e-3)]
    return df


def func_4PLb1_ln(T, a, c1, c2, d):
    """
    Adapted 4PL function for fitting two target concentrations at the same time.
    https://www.biolegend.com/en-us/blog/curve-fitting-for-immunoassays-legendplex
    Setting b=1.

    :param T: (2, ...) numpy array of target concentrations.
    :param a: scalar. Minimum readout value of binding curve.
    :param c1: scalar. K_d against target 1.
    :param c2: scalar. K_d against target 2.
    :param d: scalar. Maximum readout value of binding curve
    :return: (...) reads generated by the samples. Returns same shape as target concentrations.
    """
    tmp = np.logaddexp(T[0] - c1, T[1] - c2)
    return d + (a - d) / (1 + np.exp(tmp))


def func_4PLb1_ln_(T, a, c, d):
    """
    4PL function with b=1.
    https://www.biolegend.com/en-us/blog/curve-fitting-for-immunoassays-legendplex

    :param T: (...) numpy array of target concentrations.
    :param a: scalar. Minimum readout value of binding curve.
    :param c: scalar. K_d against target.
    :param d: scalar. Maximum readout value of binding curve
    :return: (...) reads generated by the samples. Returns same shape as target concentrations.
    """
    return d + (a - d) / (1 + np.exp(T - c))


def fit_KD_r_b1(concs, reads):
    """
    Fitting K_D values to read values by minimizing the following loss:
    loss = ||reads - func_4PLb1_ln(concs, a, c1, c2, d)||_2^2

    This assumes that the given concentrations are accurate, and that all noise is Gaussian and
    comes from the readout.

    :param concs: (2, n) concentrations of each experimental condition.
    :param reads: (n) readouts for every experimental condition.
    :return: Tuple (a, c1, c2, d) of parameters for func_4PLb1_ln.
    """
    # to make playing field level with fit_KD_T
    # reads = reads[np.any(concs > 0, axis=0)]
    # concs = concs[np.repeat(np.any(concs > 0, axis=0, keepdims=True), 2, 0)]
    log_concs = np.log(concs)
    # loss = ||reads - func_4PL_log(concs, a,b,c,d)||_2^2
    popt = curve_fit(func_4PLb1_ln, log_concs, reads,
                     p0=(np.min(reads) / 2, -4, -4, np.max(reads) * 2), check_finite=False)
    return popt[0]


if __name__ == '__main__':
    # load data
    df = read_data()
    # only use data where only one of the target concentrations is non-zero
    criterion = df.singleplex
    view = df[criterion]
    # convert from dataframe to numpy array
    concs = np.stack([view.kyn_M.to_numpy(), view.xa_M.to_numpy()], axis=0)

    for name, reads in [('SK1', view.read_SK1.to_numpy()),
                        ('XA1', view.read_XA1.to_numpy())]:  # iterate over aptamers
        print(f'{name}')
        X = np.logspace(-8, -2, 100)
        # find KDs of the aptamer against all targets
        params = fit_KD_r_b1(concs, reads)  # (min_read, ln(KD_kyn), ln(KD_xa), max_read)

        # print the fitted parameters
        print(
            f'r based params (b=1) = {params[0]}, '
            f'{np.log10(np.exp(params[1]))}, '
            f'{np.log10(np.exp(params[2]))}, '
            f'{params[3]}')

        # plot the resulting fits
        for i, label in enumerate(['Kyn', 'XA']):
            inds = concs[1 - i, :] == 0
            concs_ind = concs[i, inds]
            reads_ind = reads[inds]
            plt.scatter(concs_ind, reads_ind)
            plt.plot(X, func_4PLb1_ln_(np.log(X), params[0], params[1 + i], params[-1]))

            plt.xlabel(label)
            plt.xscale('log')
            plt.title(name)
            plt.ylabel('signal')
            plt.grid()
            plt.show()
