"""Collection of helper functions."""
from typing import Callable, Union

import numpy as np

from cr_utils.nonlinearities import langmuir, langmuir_off

non_linearities: dict[
    str, tuple[Callable[[np.ndarray], np.ndarray], Callable[[np.ndarray], np.ndarray]]] = {
    'langmuir': (langmuir.forward, langmuir.reverse),
    'langmuir_off': (langmuir_off.forward, langmuir_off.reverse)
}


def get_readouts(K_A: np.ndarray,
                 target_concs: np.ndarray,
                 f: str | Callable[[np.ndarray], np.ndarray] = 'langmuir') -> np.ndarray:
    """
    Return the readouts for the given target_concs generated by affinity reagents with affinity
    constants K_A, and non-linearity f.

    2022-12-09 Linus A. Hein.

    :param K_A: (m, n) Affinity coefficients of all m affinity reagents against all n targets.
    :param target_concs: (n, ...) Target concentrations.
    :param f: Non-linearity to use in conversion from K_A @ target_concs to actual readouts.
        Pre-programmed non-linearities are: "langmuir".
    :return: (m, ...) readouts calculated by f(K_A @ target_concs). All dimensions but the first
        match target_concs.
    """
    if isinstance(f, str):
        f = non_linearities[f][0]
    m, n = K_A.shape
    if n != target_concs.shape[0]:
        raise Exception(f'Dimension mismatch: K_A is ({m}, {n}), but first dimension of '
                        f'target_concs is {target_concs.shape[0]}')

    input_shape = target_concs.shape[1:]
    target_concs = target_concs.reshape((n, -1))
    return f(K_A @ target_concs).reshape((m, *input_shape))


def get_r_bounds(readouts: np.ndarray,
                 max_abs_error: Union[float, np.ndarray],
                 max_rel_error: Union[float, np.ndarray] = 0.0) -> np.ndarray:
    """
    Given a numpy array of readouts, returns the lower and upper bounds as given by:
        - lower bound = readout * (1 - max_rel_error) - max_abs_error
        - upper bound = readout * (1 + max_rel_error) + max_abs_error

    2022-12-09 Linus A. Hein.

    :param readouts: (m, ...) numpy array of readouts.
    :param max_abs_error: maximum absolute error. Must either a float value to be applied to all
        readouts, or a numpy array of the same shape as readouts.
    :param max_rel_error: maximum relative error. Must either a float value to be applied to all
        readouts, or a numpy array of the same shape as readouts.
    :return: (m, 2, ...) output[:, 0, ...] contains the lower bound, output[:, 1, ...] contains the
        upper bound on the readout value.
    """
    if isinstance(max_abs_error, np.ndarray):
        assert max_abs_error.shape == readouts.shape

    if isinstance(max_rel_error, np.ndarray):
        assert max_rel_error.shape == readouts.shape

    lower_bounds = readouts * (1 - max_rel_error) - max_abs_error
    upper_bounds = readouts * (1 + max_rel_error) + max_abs_error

    return np.stack([lower_bounds, upper_bounds], axis=1)


def get_r_bounds_measured(readouts_avg: np.ndarray,
                          readouts_std: np.ndarray,
                          n_std: float) -> np.ndarray:
    """
    Given the mean and standard deviation of readouts, returns the lower and upper bounds given by:
        - lower bound = readout - n_std * readouts_std
        - upper bound = readout + n_std * readouts_std

    2023-06-01 Linus A. Hein.

    :param readouts_avg: (m, ...) numpy array of averages of readouts.
    :param readouts_std: (m, ...) numpy array of standard deviations of readouts.
    :param n_std: scalar. Number of standard deviations away from the mean.
    :return: (m, 2, ...) output[:, 0, ...] contains the lower bound, output[:, 1, ...] contains the
        upper bound on the readout value.
    """
    assert readouts_avg.shape == readouts_std.shape

    lower_bounds = readouts_avg - n_std * readouts_std
    upper_bounds = readouts_avg + n_std * readouts_std

    return np.stack([lower_bounds, upper_bounds], axis=1)


def get_affine_bounds(readout_bounds,
                      f_inv: str | Callable[[np.ndarray], np.ndarray] = 'langmuir') -> np.ndarray:
    """
    Convert bounds on readout values into bounds on K_A @ target_concs.
    Be aware that using a function that is monotonically decreasing means you have to flip your
    lower and upper bounds.

    2022-12-09 Linus A. Hein.

    :param readout_bounds: (...) bounds on the readouts.
    :param f_inv: Inverse non-linearity to use in conversion from readouts to K_A @ target_concs
        values. Pre-programmed non-linearities are: "langmuir".
    :return: (...) bounds on K_A @ target_concs.
    """
    if isinstance(f_inv, str):
        f_inv = non_linearities[f_inv][1]
    return f_inv(readout_bounds)


def get_standard_physical_bounds(n_targets):
    """
    Return most lenient physical bounds, i.e., a lower bound of 0 and an upper bound of infinity.

    2022-12-09 Linus A. Hein.

    :param n_targets: Number of targets.
    :return: (n_targets, 2) Array signifying lower and upper bounds.
    """
    phys_bounds = np.zeros((n_targets, 2))
    phys_bounds[:, 1] = np.infty
    return phys_bounds


if __name__ == '__main__':
    target_concs = np.array([
        [1.0, 2.0, 1.0],
        [1.0, 2.0, 4.0]
    ])  # 2 targets, 3 samples
    K_A = np.array([
        [1.0, 1.0],
        [2.0, 1.0],
        [3.0, 1.0],
        [4.0, 1.0]
    ])  # 4 affinity reagents, 2 targets
    r = get_readouts(K_A, target_concs)  # 4 affinity reagents, 3 samples
    print(f"{r=}")
    r_bounds = get_r_bounds(r, 0.05)  # 4 affinity reagents, 2 bounds, 3 samples
    print(f"{r_bounds=}")
    affine_bounds = get_affine_bounds(r_bounds)  # 4 affinity reagents, 2 bounds,3 samples
    print(f'{affine_bounds=}')
